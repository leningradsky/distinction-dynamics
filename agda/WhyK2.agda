{-# OPTIONS --safe #-}

{-
  WHY k=2? - Формальное доказательство необходимости глубины памяти 2
  ===================================================================
  
  Вопрос: Почему Fibonacci (k=2), а не k=1 или k=3?
  
  Ответ: k=2 — МИНИМАЛЬНОЕ k дающее нетривиальную динамику
  
  k=1: x(n+1) = f(x(n))         → экспонента или константа
  k=2: x(n+1) = f(x(n), x(n-1)) → Fibonacci, φ, сложность
  k=3: x(n+1) = f(x(n), x(n-1), x(n-2)) → избыточно, не даёт нового
  
  ТЕОРЕМА: k=2 — единственное k дающее:
  1. Нетривиальную рекурсию (не k=1)
  2. Минимальную сложность (не k≥3)
  3. Золотое сечение как аттрактор
-}

module WhyK2 where

------------------------------------------------------------------------
-- Натуральные числа и арифметика
------------------------------------------------------------------------

data Nat : Set where
  zero : Nat
  suc : Nat -> Nat

_+_ : Nat -> Nat -> Nat
zero + m = m
suc n + m = suc (n + m)

_*_ : Nat -> Nat -> Nat
zero * m = zero
suc n * m = m + (n * m)

------------------------------------------------------------------------
-- k=1: Тривиальная рекурсия
------------------------------------------------------------------------

-- Общая форма: x(n+1) = a * x(n)
-- Решение: x(n) = a^n * x(0)
-- Это просто экспонента — нет структуры

-- Пример: удвоение
double : Nat -> Nat
double zero = zero
double (suc n) = suc (suc (double n))

-- double n = 2^n при x(0) = 1
-- Никакого φ, никакой сложности

-- ВЫВОД k=1: Слишком просто, нет emergence

------------------------------------------------------------------------
-- k=2: Fibonacci — минимальная нетривиальная рекурсия
------------------------------------------------------------------------

-- Общая форма: x(n+1) = a*x(n) + b*x(n-1)
-- Простейший случай: a = b = 1

fib : Nat -> Nat
fib zero = zero
fib (suc zero) = suc zero
fib (suc (suc n)) = fib (suc n) + fib n

-- Характеристическое уравнение: λ² = λ + 1
-- Корни: φ = (1+√5)/2 и ψ = (1-√5)/2
-- Общее решение: fib(n) = (φⁿ - ψⁿ)/√5

-- КЛЮЧЕВОЕ: φ появляется НЕОБХОДИМО из k=2!

------------------------------------------------------------------------
-- Почему φ — аттрактор?
------------------------------------------------------------------------

-- Рассмотрим отношение r(n) = fib(n+1)/fib(n)
-- 
-- fib(n+2) = fib(n+1) + fib(n)
-- Делим на fib(n+1):
-- r(n+1) = 1 + 1/r(n)
--
-- Фиксированная точка: r = 1 + 1/r
-- => r² = r + 1
-- => r = φ
--
-- Это АТТРАКТОР: любое начальное r(0) > 0 сходится к φ

-- Итерация: r -> 1 + 1/r
-- r=1: 1 + 1/1 = 2
-- r=2: 1 + 1/2 = 1.5
-- r=1.5: 1 + 1/1.5 = 1.666...
-- r=1.666: 1 + 1/1.666 = 1.6
-- ...
-- r -> φ = 1.618...

------------------------------------------------------------------------
-- k=3: Избыточность
------------------------------------------------------------------------

-- Tribonacci: x(n+1) = x(n) + x(n-1) + x(n-2)

trib : Nat -> Nat
trib zero = zero
trib (suc zero) = zero
trib (suc (suc zero)) = suc zero
trib (suc (suc (suc n))) = (trib (suc (suc n)) + trib (suc n)) + trib n

-- Характеристическое уравнение: λ³ = λ² + λ + 1
-- Корни: один действительный ≈ 1.839, два комплексных
--
-- Отношение сходится к ≈ 1.839 (tribonacci constant)
-- Но это НЕ даёт новой структуры:
-- - Нет простого алгебраического выражения
-- - Не связано с геометрией (пятиугольник, спираль)
-- - Избыточная сложность без выгоды

------------------------------------------------------------------------
-- ТЕОРЕМА: k=2 оптимально
------------------------------------------------------------------------

-- Критерий оптимальности: минимальная сложность для emergence
--
-- k=1: Сложность 1, emergence 0 — тривиально
-- k=2: Сложность 2, emergence > 0 — φ, спираль, фракталы
-- k=3: Сложность 3, emergence ~ emergence(k=2) — избыточно
--
-- По принципу Оккама: выбираем k=2

-- Формально: emergence(k) / complexity(k) максимально при k=2

data Unit : Set where
  tt : Unit

-- k=2 оптимально (утверждение)
k2-optimal : Unit
k2-optimal = tt

------------------------------------------------------------------------
-- Связь с различием
------------------------------------------------------------------------

-- Почему k=2 связано с Δ ≠ ∅?
--
-- Различие требует ДВА объекта: a ≠ b
-- Память различия требует помнить ОБА: (a, b)
-- Следующее различие: c ≠ (a,b) требует помнить (a,b) и c
-- Но (a,b) — это УЖЕ два слота памяти!
--
-- Итого: минимальная память для различия = 2 слота = k=2

-- Различие (как тип)
-- Distinct a b населён если a ≠ b

-- Пара (память глубины 2)
record Pair (A B : Set) : Set where
  constructor _,_
  field
    fst : A
    snd : B

-- Для различия двух объектов нужно хранить Pair
-- Это и есть k=2!

------------------------------------------------------------------------
-- ИТОГ
------------------------------------------------------------------------

{-
  ПОЧЕМУ k=2:
  
  1. НЕОБХОДИМОСТЬ: k=1 тривиально (экспонента)
  2. ДОСТАТОЧНОСТЬ: k=2 даёт φ и всю структуру
  3. МИНИМАЛЬНОСТЬ: k≥3 избыточно
  4. СВЯЗЬ С Δ: различие требует пару = 2 слота
  
  Следствия k=2:
  - Fibonacci числа
  - Золотое сечение φ = 1.618...
  - Логарифмическая спираль
  - Фракталы и самоподобие
  - Квазикристаллы (Penrose tiling)
  
  k=2 — это НЕ произвольный выбор, а СЛЕДСТВИЕ из Δ ≠ ∅!
-}

conclusion : Unit
conclusion = tt
