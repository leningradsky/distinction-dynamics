{-# OPTIONS --safe --without-K #-}

{-
  ACCUMULATING TRIAD: A → AB → ABC → A'(ABC)
  ==========================================
  
  Формализация идеи:
  - Каждый шаг СОДЕРЖИТ предыдущие
  - Финальный шаг = самореференция
  - A' ≠ A, но A' содержит A
  
  Это НЕ цикл (A → B → C → A)
  Это СПИРАЛЬ (рост с возвратом на новом уровне)
-}

module AccumTriad where

------------------------------------------------------------------------
-- БАЗОВЫЕ ОПРЕДЕЛЕНИЯ
------------------------------------------------------------------------

data Void : Set where

infix 4 _==_
data _==_ {A : Set} (x : A) : A -> Set where
  refl : x == x

record _×_ (A B : Set) : Set where
  constructor _,_
  field
    fst : A
    snd : B
open _×_

data Nat : Set where
  zero : Nat
  suc  : Nat -> Nat

{-# BUILTIN NATURAL Nat #-}

------------------------------------------------------------------------
-- КЛЮЧЕВАЯ СТРУКТУРА: ИСТОРИЯ
------------------------------------------------------------------------

-- История = накопленный путь
-- Каждый шаг помнит все предыдущие

data History : Set where
  origin : History                    -- начало (пустая история)
  step   : History -> History         -- шаг, помнящий предыдущее

-- Глубина истории
depth : History -> Nat
depth origin = 0
depth (step h) = suc (depth h)

------------------------------------------------------------------------
-- РАЗЛИЧЕНИЕ С ИСТОРИЕЙ
------------------------------------------------------------------------

-- Δ с контекстом: различение + откуда оно пришло
record Δ-in-context : Set where
  constructor _at_
  field
    content : History    -- что это такое
    path    : History    -- как мы сюда попали

-- Ключевое: два Δ-in-context равны только если равны И content И path
-- Даже "одинаковое содержание" различается, если путь разный!

------------------------------------------------------------------------
-- ТРИ ШАГА ТРИАДЫ
------------------------------------------------------------------------

-- Шаг 0: голое A (различение само по себе)
A₀ : History
A₀ = origin

-- Шаг 1: AB = A + память о том, что мы отличили A от не-A
A₁ : History
A₁ = step origin    -- origin (A) + шаг (отличение)

-- Шаг 2: ABC = AB + память об отношении A и не-A
A₂ : History
A₂ = step (step origin)   -- origin + шаг + шаг

-- Шаг 3: A' = A₂ + рефлексия = возврат к A, но обогащённый
A₃ : History
A₃ = step (step (step origin))

-- Проверка глубин
_ : depth A₀ == 0
_ = refl

_ : depth A₁ == 1
_ = refl

_ : depth A₂ == 2
_ = refl

_ : depth A₃ == 3
_ = refl

------------------------------------------------------------------------
-- СОДЕРЖИТ: A₃ СОДЕРЖИТ A₀
------------------------------------------------------------------------

-- Определение: h' содержит h, если h — префикс пути к h'
data _contains_ : History -> History -> Set where
  self     : {h : History} -> h contains h
  through  : {h h' : History} -> h' contains h -> (step h') contains h

-- A₃ содержит A₀
A₃-contains-A₀ : A₃ contains A₀
A₃-contains-A₀ = through (through (through self))

-- A₃ содержит A₁
A₃-contains-A₁ : A₃ contains A₁
A₃-contains-A₁ = through (through self)

-- A₃ содержит A₂
A₃-contains-A₂ : A₃ contains A₂
A₃-contains-A₂ = through self

------------------------------------------------------------------------
-- НО A₃ ≠ A₀
------------------------------------------------------------------------

-- A₃ не равно A₀ (разная глубина)
A₃≠A₀ : A₃ == A₀ -> Void
A₃≠A₀ ()   -- абсурд: step (step (step origin)) ≠ origin

------------------------------------------------------------------------
-- ЗАМЫКАНИЕ = САМОРЕФЕРЕНЦИЯ
------------------------------------------------------------------------

-- Система замкнута, когда может указать на себя целиком

-- Для этого нужно минимум 3 шага:
-- Шаг 0: есть объект
-- Шаг 1: есть отличие объекта
-- Шаг 2: есть наблюдение отличия
-- = Объект видит своё отличие = самореференция

-- Формально: замкнутость = существование карты "обратно с памятью"

-- Забывающая проекция: A₃ -> A₀ (отбросить историю)
forget : History -> History
forget origin = origin
forget (step h) = origin

-- Обогащающее вложение: A₀ -> A₃ (сохранить путь)
-- Это НЕ обратная функция к forget!

enrich : History -> History -> History
enrich h origin = h
enrich h (step path) = step (enrich h path)

-- enrich A₀ A₃ = A₃ (A₀ в контексте A₃ = A₃)
-- Это и есть: A' = A в контексте всего пути

------------------------------------------------------------------------
-- ТРИАДА КАК ТИП
------------------------------------------------------------------------

-- Триадическая структура: три позиции + отношение между ними
record Triad : Set₁ where
  field
    Pos     : Set           -- первый полюс
    Neg     : Set           -- второй полюс  
    Witness : Pos -> Neg -> Set   -- отношение (не значение, а тип!)

-- Это важно: Witness — не функция в значение, а ПРОПОЗИЦИЯ
-- "pos и neg связаны" — это утверждение, которое может быть истинным или нет

-- Пример: триада истории
HistoryTriad : Triad
HistoryTriad = record
  { Pos = History
  ; Neg = History
  ; Witness = _contains_
  }

------------------------------------------------------------------------
-- МИНИМАЛЬНОСТЬ ТРИАДЫ
------------------------------------------------------------------------

-- Почему именно 3?

-- С 1 элементом: нет различения
-- С 2 элементами: есть различение, но нет наблюдателя различения
-- С 3 элементами: различение + наблюдатель = замкнутость

-- Формально:
-- Уровень 0 (1 элемент): origin
-- Уровень 1 (2 элемента): origin, step origin
-- Уровень 2 (3 элемента): origin, step origin, step (step origin)
--   На этом уровне: step (step origin) ВИДИТ отношение между origin и step origin

-- Это минимально необходимо для самореференции

------------------------------------------------------------------------
-- WOBBLE: ТРЕТЬЯ ПОЗИЦИЯ КАК СИГНАЛ ЗАВЕРШЕНИЯ
------------------------------------------------------------------------

-- В генетическом коде:
-- Позиция 1: что (содержание)
-- Позиция 2: как (контекст)
-- Позиция 3: wobble = "сообщение завершено"

-- Wobble несёт меньше информации потому что это НЕ данные
-- Это МЕТАДАННЫЕ: сигнал замкнутости

data CodonPosition : Set where
  content  : CodonPosition    -- позиция 1: информация о чём
  context  : CodonPosition    -- позиция 2: информация о как
  closure  : CodonPosition    -- позиция 3: сигнал "всё"

-- Информационная нагрузка убывает:
-- content: полная
-- context: частичная  
-- closure: минимальная (только да/нет замкнутости)

------------------------------------------------------------------------
-- СПИРАЛЬ ВРЕМЕНИ
------------------------------------------------------------------------

-- Время — не цикл (возврат к тому же), а спираль (возврат на новом уровне)

-- "Сейчас" = текущая глубина истории
-- "Вернуться назад" = невозможно (history только растёт)
-- "Повторить момент" = возможно, но на новой глубине

-- Это необратимость времени: step h ≠ h

step≠self : {h : History} -> step h == h -> Void
step≠self ()

-- Невозможно "отменить" шаг, вернуться к предыдущему моменту
-- Можно только идти дальше, неся память

------------------------------------------------------------------------
-- СОЗНАНИЕ КАК ТРИАДА
------------------------------------------------------------------------

-- Я = origin (базовое различение я/не-я)
-- Мир = step origin (то, что я отличаю от себя)
-- Осознание = step (step origin) (я, видящий своё отличение мира)

-- Осознание СОДЕРЖИТ и Я, и Мир, но не равно им
-- Осознание = Я', обогащённое опытом различения

------------------------------------------------------------------------
-- ИТОГ
------------------------------------------------------------------------

{-
  ТРИАДА DD:
  
  Не:   A → B → C → A     (плоский цикл)
  А:    A → AB → ABC → A'  (спиральное накопление)
  
  Где:
  - AB = A + различение A от не-A
  - ABC = AB + наблюдение этого различения
  - A' = A, содержащее весь путь (A' contains A, но A' ≠ A)
  
  Замкнутость:
  - Не "вернулись к началу"
  - А "можем указать на себя целиком"
  - Минимум 3 шага для самореференции
  
  Импликации:
  - Время необратимо (step h ≠ h)
  - Третья позиция = сигнал завершения, не данные
  - Сознание = триадическая структура (Я, Мир, Осознание)
-}
