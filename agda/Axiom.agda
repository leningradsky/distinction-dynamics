{-# OPTIONS --safe --without-K #-}

{-
  AXIOM - Единственная аксиома DD
  ================================
  
  Δ ≠ ∅
  
  Различение существует и не пусто.
-}

module Axiom where

open import Base

------------------------------------------------------------------------
-- АКСИОМА
------------------------------------------------------------------------

-- Δ≠∅: существует тип с минимум двумя различными элементами

record Distinction-Exists : Set₁ where
  field
    Carrier : Set
    d₁ : Carrier
    d₂ : Carrier
    distinct : d₁ == d₂ -> Void

------------------------------------------------------------------------
-- МИНИМАЛЬНАЯ РЕАЛИЗАЦИЯ
------------------------------------------------------------------------

-- Bool реализует Δ≠∅

bool-distinction : Distinction-Exists
bool-distinction = record
  { Carrier = Bool
  ; d₁ = true
  ; d₂ = false
  ; distinct = true/=false
  }
  where
    true/=false : true == false -> Void
    true/=false ()

------------------------------------------------------------------------
-- СЛЕДСТВИЕ 1: СУЩЕСТВУЕТ ДВА
------------------------------------------------------------------------

-- Из Δ≠∅ немедленно следует: есть минимум два различных объекта

Two-Exist : Set₁
Two-Exist = Distinction-Exists

------------------------------------------------------------------------
-- СЛЕДСТВИЕ 2: СУЩЕСТВУЕТ РАЗЛИЧЕНИЕ
------------------------------------------------------------------------

-- Само различение d₁ от d₂ — это третий объект
-- (не d₁, не d₂, но "отношение" между ними)

-- Формально: тип (d₁ == d₂ -> Void) населён

Distinction-Is-Third : Distinction-Exists -> Set
Distinction-Is-Third D = Distinction-Exists.d₁ D == Distinction-Exists.d₂ D -> Void

third-exists : (D : Distinction-Exists) -> Distinction-Is-Third D
third-exists D = Distinction-Exists.distinct D

------------------------------------------------------------------------
-- СЛЕДСТВИЕ 3: МИНИМУМ ТРИ
------------------------------------------------------------------------

-- d₁, d₂, и само различение (d₁≠d₂) = три "объекта"
-- Это концептуально, не формально (различение не того же типа)

-- Но можно построить тип с тремя элементами из Δ≠∅:

data Three : Set where
  one   : Three
  two   : Three
  three : Three

one/=two : one == two -> Void
one/=two ()

one/=three : one == three -> Void
one/=three ()

two/=three : two == three -> Void
two/=three ()

three-distinction : Distinction-Exists
three-distinction = record
  { Carrier = Three
  ; d₁ = one
  ; d₂ = two
  ; distinct = one/=two
  }

------------------------------------------------------------------------
-- СЛЕДСТВИЕ 4: НАКОПЛЕНИЕ
------------------------------------------------------------------------

-- Если есть различение, различённое тоже различается
-- A ≠ B => (A, контекст₁) ≠ (A, контекст₂) при контекст₁ ≠ контекст₂

-- Это порождает накопление: A -> AB -> ABC -> ...

------------------------------------------------------------------------
-- СЛЕДСТВИЕ 5: ЗАМЫКАНИЕ
------------------------------------------------------------------------

-- После трёх шагов возможно замыкание:
-- A -> B -> C -> A'
-- где A' ≠ A, но A' "содержит" информацию об A

-- Это минимум для самореференции

------------------------------------------------------------------------
-- НЕ-АКСИОМЫ
------------------------------------------------------------------------

-- DD НЕ постулирует:
-- - Какие именно объекты существуют (только что есть различение)
-- - Сколько объектов (только что минимум 2)
-- - Какова природа объектов (только что они различимы)
-- - Пространство, время, причинность (выводятся)

------------------------------------------------------------------------
-- ИТОГ
------------------------------------------------------------------------

{-
  ЕДИНСТВЕННАЯ АКСИОМА:
  
  Δ ≠ ∅
  (Различение существует и не пусто)
  
  НЕМЕДЛЕННЫЕ СЛЕДСТВИЯ:
  
  1. Существует минимум 2 различных объекта
  2. Существует само различение (третье)
  3. Различённое различается (накопление)
  4. Накопление замыкается (триада)
  
  ВСЁ ОСТАЛЬНОЕ ВЫВОДИТСЯ.
-}
