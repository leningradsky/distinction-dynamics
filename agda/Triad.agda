{-# OPTIONS --safe --without-K #-}

{-
  TRIAD - Триадическая структура
  ===============================
  
  A -> AB -> ABC -> A'
  
  Минимум для замыкания и самореференции.
-}

module Triad where

open import Base

------------------------------------------------------------------------
-- ТРИАДА КАК ТИП
------------------------------------------------------------------------

data Triad : Set where
  pos : Triad   -- A: позиция, тезис
  neg : Triad   -- B: негация, антитезис
  syn : Triad   -- C: синтез, замыкание

------------------------------------------------------------------------
-- ТРИАДА РАЗЛИЧНА
------------------------------------------------------------------------

pos/=neg : pos == neg -> Void
pos/=neg ()

pos/=syn : pos == syn -> Void
pos/=syn ()

neg/=syn : neg == syn -> Void
neg/=syn ()

------------------------------------------------------------------------
-- НАКОПЛЕНИЕ
------------------------------------------------------------------------

-- История как накопление шагов
data History : Set where
  origin : History
  step   : History -> History

-- Глубина истории
depth : History -> Nat
depth origin = zero
depth (step h) = suc (depth h)

-- Шаг необратим
step/=self : (h : History) -> step h == h -> Void
step/=self origin ()
step/=self (step h) ()

------------------------------------------------------------------------
-- НАКОПЛЕНИЕ ДО ТРИАДЫ
------------------------------------------------------------------------

-- Накопление глубины n
data Accum (A : Set) : Nat -> Set where
  base : A -> Accum A zero
  acc  : {n : Nat} -> Accum A n -> A -> Accum A (suc n)

-- Триада = накопление глубины 2
TriadAccum : Set -> Set
TriadAccum A = Accum A 2

-- Построить триаду
mkTriad : {A : Set} -> A -> A -> A -> TriadAccum A
mkTriad a b c = acc (acc (base a) b) c

------------------------------------------------------------------------
-- ИЗВЛЕЧЕНИЕ ИЗ ТРИАДЫ
------------------------------------------------------------------------

-- Первый элемент (A)
triad-first : {A : Set} -> TriadAccum A -> A
triad-first (acc (acc (base a) _) _) = a

-- Второй элемент (B)
triad-second : {A : Set} -> TriadAccum A -> A
triad-second (acc (acc _ b) _) = b

-- Третий элемент (C)
triad-third : {A : Set} -> TriadAccum A -> A
triad-third (acc _ c) = c

------------------------------------------------------------------------
-- СПИРАЛЬ
------------------------------------------------------------------------

-- Замыкание: триада -> новое начало
-- A' содержит (A, B, C) но A' /= A

record Spiral (A : Set) : Set where
  field
    content : TriadAccum A      -- накопленное (A, B, C)
    closure : A                  -- новое A' (результат замыкания)
    enriched : triad-first content == closure -> Void  -- A' /= A

------------------------------------------------------------------------
-- МИНИМАЛЬНОСТЬ ТРИАДЫ
------------------------------------------------------------------------

-- Почему 3, не 2?
-- 
-- С двумя: A, B
-- Можно различить A от B
-- Но нельзя замкнуть: нет "места" для результата различения
-- 
-- С тремя: A, B, C
-- A - исходное
-- B - отличное от A
-- C - синтез/замыкание
-- C может стать новым A (спираль)

-- Двойка не замыкается
data Dyad : Set where
  first  : Dyad
  second : Dyad

-- Нет третьего для замыкания
-- (это не теорема, это наблюдение структуры)

------------------------------------------------------------------------
-- СВЯЗЬ С ЗОНАМИ
------------------------------------------------------------------------

-- Триада порождает топологию I/B/E
-- pos ~ interior (исходное внутри)
-- neg ~ boundary (контраст на границе)
-- syn ~ exterior (синтез выходит наружу)

-- Это не формальная теорема, а интерпретация

------------------------------------------------------------------------
-- ИТЕРАЦИЯ
------------------------------------------------------------------------

-- Уровень n = триада в триаде в... (n раз)

Closed : Set -> Set
Closed A = Sigma (TriadAccum A) (\t -> A)

-- Level 0: A
-- Level 1: Closed A
-- Level 2: Closed (Closed A)
-- ...

Level0 : Set -> Set
Level0 A = A

Level1 : Set -> Set
Level1 A = Closed A

Level2 : Set -> Set
Level2 A = Closed (Closed A)

Level3 : Set -> Set
Level3 A = Closed (Closed (Closed A))
